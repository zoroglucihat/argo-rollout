<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>adesso Turkey on adesso docs site</title>
    <link>http://example.org/</link>
    <description>Recent content in adesso Turkey on adesso docs site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Business Context</title>
      <link>http://example.org/03_context/01_business/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/03_context/01_business/</guid>
      <description>3.1 Business Context Fig.: Business Context of DokChess Human opponent (user) Chess is played between two opponents, who move their pieces in turn. DokChess takes the role of one of the opponents, and competes against a human opponent. For this purpose, the two need to communicate, e.g. about their moves, or draw offers.
Computer opponent (external system) As an alternative to a human opponent DokChess can also compete with a different engine.</description>
    </item>
    
    <item>
      <title>Dependencies</title>
      <link>http://example.org/08_concepts/01_dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/01_dependencies/</guid>
      <description>8.1 Dependencies Between Modules DokChess invites developers to experiment and to extend the engine (→ 1.1 Requirements Overview). In order to do so, the modules are loosely coupled. DokChess modules are implementations of Java interfaces. Java classes that require parts signal this with appropriate methods set«Module»(«Interface» &amp;hellip;). They don&amp;rsquo;t take care of resolving a dependency, for instance, by using a factory. Instead, the client resolves the dependencies by creating suitable implementations with new and putting them together with setter methods (also known as Dependency Injection, short DI).</description>
    </item>
    
    <item>
      <title>Frontend Connection</title>
      <link>http://example.org/11_risks/01_frontend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/11_risks/01_frontend/</guid>
      <description>11.1 Risk: Connecting to the Frontend fails There is no knowledge about connecting an engine to an existing chess frontend. Available open source engines are programmed in C and are delivered as executable programs (*.exe). Since DokChess is developed in Java, they are of limited use as examples. Nothing is known in the project about chess communication protocols.
If it is not possible to make a working connection, the solution can not be used with existing frontends.</description>
    </item>
    
    <item>
      <title>Frontend Connectivity</title>
      <link>http://example.org/09_decisions/01_connectivity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/09_decisions/01_connectivity/</guid>
      <description>9.1 How Does the Engine Communicate with the Outside World? Problem Background As a central requirement DokChess must work together with existing chess frontends. How do we connect them?
A whole series of graphical user interfaces are available for playing against chess programs. Moreover, there are software solutions with a larger scope for chess enthusiasts. In addition to the game &amp;ldquo;Human vs. Machine&amp;rdquo;, they offer more functionality, such as analyzing games.</description>
    </item>
    
    <item>
      <title>Technical</title>
      <link>http://example.org/02_constraints/01_technical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/02_constraints/01_technical/</guid>
      <description>2.1 Technical Constraints Teknik kısıtlamalar
Constraint Background and / or motivation Moderate hardware equipment Operating XXX on a standard notebook in order to show the software in the context of workshops and conferences on such a device. Operating on Windows desktop operating systems Standard equipment for notebooks of oose employees at the time of outlining the solution. High distribution of these operating systems at potentially interested parties (audience at conference talks, participants in trainings).</description>
    </item>
    
    <item>
      <title>Utility Tree</title>
      <link>http://example.org/10_qualityrequirements/01_utilitytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/10_qualityrequirements/01_utilitytree/</guid>
      <description>10.1 Utility Tree The following diagram gives an overview of the relevant quality attributes and their associated scenarios. The quality goals are also included in the figure, and each refers to the scenarios that illustrate them.</description>
    </item>
    
    <item>
      <title>Deployment Context</title>
      <link>http://example.org/03_context/02_deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/03_context/02_deployment/</guid>
      <description>3.2 Deployment Context Fig.: Technical communication of DokChess with third parties XBoard client (external system) A human player is connected to DokChess with a graphical front-end. The development of such is not part of DokChess. Each graphical frontend can be used instead, if it supports the so-called XBoard protocol. These include Xboard (or Winboard on Windows), Arena and Aquarium.
Polyglot Opening Book (external system) Polyglot Opening Book is a binary file format for opening libraries.</description>
    </item>
    
    <item>
      <title>Domain Model</title>
      <link>http://example.org/08_concepts/02_domainmodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/02_domainmodel/</guid>
      <description>8.2 Chess Domain Model &amp;ldquo;The game of chess is played between two opponents who move their pieces on a square board called a ‘chessboard’.&amp;rdquo;&amp;quot;
from the FIDE Laws of Chess
The different modules of DokChess exchange chess-specific data. This includes the game situation on the chessboard (position) for instance, as well as opponent&amp;rsquo;s and own moves. All interfaces use the same domain objects as call and return parameters.
This section contains a brief overview of these data structures and their relationships.</description>
    </item>
    
    <item>
      <title>Effort</title>
      <link>http://example.org/11_risks/02_effort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/11_risks/02_effort/</guid>
      <description>11.2 Risk: Implementation effort too high There is no experience with chess programming. Simultaneously, the rules that are to be implemented completely (→ 1.1 Requirements Overview) are extensive and complicated. The different pieces move differently, and there are special rules such as stalemate and promotion. In the case of castling and en passant, the move history, and not only the current situation on the board, is relevant.
The programming of the algorithms is also non-trivial.</description>
    </item>
    
    <item>
      <title>Organizational</title>
      <link>http://example.org/02_constraints/02_organizational/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/02_constraints/02_organizational/</guid>
      <description>2.2 Organizational Constraints Organizasyonel kısıtlamalar
Constraint Background and / or motivation Team Stefan Zörner, supported by colleagues, friends and interested workshop or training participants Schedule Start of development in December 2010, first running prototype March 2011 (evening talk at oose in Hamburg), presentable version May 2011 (talk at JAX conference in Mayence, Germany). Completion of Version 1.0: February 2012 (Deadline book manuscript for 1st edition). Process model Risk driven development, iterative and incremental.</description>
    </item>
    
    <item>
      <title>Position Objects</title>
      <link>http://example.org/09_decisions/02_positionobjects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/09_decisions/02_positionobjects/</guid>
      <description>9.2 Are Position Objects Changeable or Not? Problem Background For various DokChess modules, game situations on the chess board (so-called positions) must be provided and exchanged between them. Do we make the associated data structure changeable or unchangeable (immutable)?
During a game, the position changes when the opposing players move their pieces. In addition, the engine performs possible moves in its analysis, tries to counter the moves of the opponent, evaluates the outcoming positions, and then discards moves.</description>
    </item>
    
    <item>
      <title>Quality Scenarios</title>
      <link>http://example.org/10_qualityrequirements/02_qualityscenarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/10_qualityrequirements/02_qualityscenarios/</guid>
      <description>10.2 Quality Scenarios The initial letters of the identifiers (IDs) of the scenarios in the following table each stand for the parent quality attribute (in German), E for efficiency, for instance. These identifiers are also used in the quality tree. The scenarios cannot always be clearly assigned to one characteristic. Therefore, they sometimes appear several times in the quality tree.
ID Scenario W01 A person with basic knowledge of UML and chess looks for an introduction to the DokChess architecture.</description>
    </item>
    
    <item>
      <title>Conventions</title>
      <link>http://example.org/02_constraints/03_conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/02_constraints/03_conventions/</guid>
      <description>2.3 Conventions Dokümanttasyon vs.
Convention Background and / or motivation Architecture documentation Terminology and structure according to the arc42 template, version 6.0 Coding guidelines for Java Java coding conventions of Sun / Oracle, checked using CheckStyle Chess-specific file formats Use of established standards for chess-specific notations and exchange formats within the solution. Topics: moves, positions, games, openings, &amp;hellip; Never develop own formats here. Principle: Favour open standards over proprietary formats (which commercial programs may use).</description>
    </item>
    
    <item>
      <title>Playing Strength</title>
      <link>http://example.org/11_risks/03_playingstrength/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/11_risks/03_playingstrength/</guid>
      <description>11.3 Risk: Achieving the playing strength fails The quality goals demand both an acceptable playing strength and a simple, accessible solution. In addition, there are requirements with respect to efficiency. It is uncertain whether the planned Java solution with an object-oriented domain model and simple move selection can achieve these competing goals.
The risk manifests itself through too bad playing strength, too long waiting times or both. This would be particularly unpleasant for live performances in lectures, as the solution is not perceived as such by the listeners (but as a toy).</description>
    </item>
    
    <item>
      <title>User Interface</title>
      <link>http://example.org/08_concepts/03_userinterface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/03_userinterface/</guid>
      <description>8.3	User Interface DokChess itself has no graphical user interface. It interacts via the XBoard protocol with the outside world (→ Decision 9.1 &amp;ldquo;How does the engine communicate with the outside world?&amp;rdquo;).
The XBoard protocol is text-based. If you have mastered the main commands (see Figure &amp;hellip;) starting DokChess in a command line (Unix shell, Windows command prompt, &amp;hellip;) enables you to interact with the engine. The table below shows a sample dialog, all commands are terminated with a new line).</description>
    </item>
    
    <item>
      <title>Validation</title>
      <link>http://example.org/08_concepts/04_validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/04_validation/</guid>
      <description>8.4 Plausibility Checks and Validation In simple terms, DokChess is an algorithm. It responds to moves of the opponent with its own moves. Two channels are relevant for input validation:
the XBoard protocol for interactive user input from the opponent opening libraries in the form of files Input that comes through the XBoard protocol is parsed from the corresponding subsystem. In case of unknown or unimplemented commands DokChess reports the XBoard command &amp;ldquo;Error&amp;rdquo; back to the client.</description>
    </item>
    
    <item>
      <title>Error Handling</title>
      <link>http://example.org/08_concepts/05_errorhandling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/05_errorhandling/</guid>
      <description>8.5 Exception and Error Handling DokChess has no own user interface. Therefore it must indicate problems to the outside world.
All DokChess subsystem methods throw Runtime Exceptions. In addition in case of the Engine subsystem error messages (onError) may occur during an asynchronous search. Your own extensions (for example a custom search) must be implemented accordingly. Checked exceptions (e.g. java.io.IOException) need to be wrapped in Runtime Exceptions.
The javadoc of methods and constructors in question shows the rare cases where exceptions are expected in DokChess.</description>
    </item>
    
    <item>
      <title>Logging</title>
      <link>http://example.org/08_concepts/06_logging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/06_logging/</guid>
      <description>8.6 Logging and Tracing For improvements and extensions the analysis capabilities provided by DokChess are of note, particularly in case of on error.
The DokChess functionality itself can be checked easily with unit tests. This is particularly true for the correct implementation of the game rules and for the game play of the engine (→ 8.7 Testability). It holds true for your own extensions in this area as well.
Therefore there is no fine-grained logging output within DokChess.</description>
    </item>
    
    <item>
      <title>Testability</title>
      <link>http://example.org/08_concepts/07_testability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/08_concepts/07_testability/</guid>
      <description>8.7 Testability Nothing is more embarrassing for an engine than an illegal move.
The functionality of the individual modules of DokChess is ensured by extensive unit tests. You find a folder src/test next to src/main, where the Java source code of the modules is stored. It mirrors the package structure, and in the corresponding packages unit tests for the classes realized with JUnit 4.
Standard unit testing, which examine the individual classes, are named as the class itself with suffix Test.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://example.org/04_solutionstrategy/01_introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/04_solutionstrategy/01_introduction/</guid>
      <description>4.1 Introduction to the Strategy The following table contrasts the quality goals of DokChess (→ Section 1.2) with matching architecture approaches and thus provides easy access to the solution.
Quality Goal Matching approaches in the solution Accessible example (Analysability) architectural overview structured by arc42explicit, object-oriented domain modeldetailed documentation of public interfaces with Javadoc Platform appealing to experiments (Changeability) widely spread programming language Java → (a)Interfaces for core abstractions (for instance: position evaluation, game rules)immutable objects (position, move, &amp;hellip; ) make implementation of many algorithms easier&amp;ldquo;plugging&amp;rdquo; of elements with dependency injection leads to interchangeability → (b)High test coverage as a safety net Using existing frontends (Interoperability) Use of the common communication protocol XBoard, → (c)Use of portable Java → (a) Acceptable playing strength (Attractiveness) Integration of chess opening book libraries → (d)implementation of minimax algorithm and a proper position evaluation → (e)Integration tests with chess problems for tactics and mate positions Quick response to opponent&amp;rsquo;s moves (Efficiency) Reactive extensions for concurrent calculation with newly found better moves as events → (f) Optimization of minimax by alpha-beta pruning → (e) Efficient domain model implementationIntegration tests with time limits Small letters in brackets, e.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://example.org/12_glossary/01_introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/12_glossary/01_introduction/</guid>
      <description>&amp;ldquo;The game of chess is played between two opponents who move their pieces on a square board called a ‘chessboard’.&amp;rdquo;
From the FIDE Laws of Chess
The following glossary contains English chess terms and terms from the world of computer chess. Some of them go beyond the vocabulary of infrequent or casual chess players.
See FIDE Laws of Chess or the Wikipedia glossary of chess for more information.
Names of the Chess Pieces Chessboard Geometry &amp;ldquo;The chessboard is composed of an 8 x 8 grid of 64 equal squares alternately light (the ‘white’ squares) and dark (the ‘black’ squares).</description>
    </item>
    
    <item>
      <title>Level 1</title>
      <link>http://example.org/05_buildingblockview/01_level1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/01_level1/</guid>
      <description>5.1	Building Block View, Level 1 DokChess breaks down in four subsystems as presented below. The dashed arrows represent logical dependencies between the subsystems (&amp;ldquo;x -&amp;gt; y&amp;rdquo; for &amp;ldquo;x depends on y&amp;rdquo;). The squared boxes on the membrane of the system are interaction points (&amp;ldquo;ports&amp;rdquo;) with the outside world (→ 3.2 Deployment Context).
Fig.: DokChess, building block view, level 1
Subsystem Short description Text UI Realizes communication with a client using the XBoard protocol.</description>
    </item>
    
    <item>
      <title>Move Determination</title>
      <link>http://example.org/06_runtimeview/01_move_determination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/06_runtimeview/01_move_determination/</guid>
      <description>6.1 Move Determination Walkthrough After establishing the XBoard protocol, the client (white) starts a game by indicating a move. The following sequence diagram shows an example interaction at the subsystem level from the input &amp;ldquo;e2e4&amp;rdquo; (white pawn e2-e4) to DokChess&amp;rsquo; response, which is the output &amp;ldquo;move b8c6&amp;rdquo; (black knight b8-c6, &amp;ldquo;Nimzowitsch defense&amp;rdquo;).
Fig.: Sample interaction for move determination
First, the Text UI subsystem validates the input with the aid of the Rules subsystem (→ Concept 8.</description>
    </item>
    
    <item>
      <title>Structure</title>
      <link>http://example.org/04_solutionstrategy/02_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/04_solutionstrategy/02_structure/</guid>
      <description>4.2 Structure of DokChess DokChess is implemented as a Java program with a main routine. It is roughly split into the following parts:
An implementation of the rules of chess The engine itself, which selects the moves The connection to a graphical user interface via the XBoard protocol An adapter for a specific opening book format (Polyglot Opening Book) This decomposition allows you to replace things such as the communication protocol or the opening book format if necessary.</description>
    </item>
    
    <item>
      <title>Windows Infrastructure</title>
      <link>http://example.org/07_deploymentview/01_windows_infrastructure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/07_deploymentview/01_windows_infrastructure/</guid>
      <description>7.1 Windows Infrastructure The following deployment diagram shows the use of DokChess on Windows without an opening book. Arena is used as an example frontend (→ Decison 9.1 &amp;ldquo;How does the engine communicate with the outside world?&amp;rdquo;).
Fig.: Deploying DokChess on a Windows PC
Software Requirements on a PC:
Java Runtime Environment SE 11 (or higher) The JVM (javaw.exe) is in the PATH, otherwise adapt dokchess.bat Arena DokChess.jar contains the compiled Java source code of all the modules and all the necessary dependencies (&amp;ldquo;Uber-jar&amp;rdquo;).</description>
    </item>
    
    <item>
      <title>Game Strategy</title>
      <link>http://example.org/04_solutionstrategy/03_gamestrategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/04_solutionstrategy/03_gamestrategy/</guid>
      <description>4.3 Game Strategy For the integration of opening libraries, the &amp;ldquo;Polyglot Opening Book&amp;rdquo; file format was implemented (→ Building Block View 5.5 &amp;ldquo;Subsystem Opening (Blackbox)&amp;rdquo;). This way, DokChess responds with profound chess knowledge in the beginning of a game.
The classic minimax algorithm with a fixed search depth in the game tree is responsible for the strategy as the game continues. Its basic implementation is single-threaded. The evaluation of a position at an end node in the game tree is based solely on the material (→ 5.</description>
    </item>
    
    <item>
      <title>Text UI</title>
      <link>http://example.org/05_buildingblockview/02_textui/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/02_textui/</guid>
      <description>5.2 Subsystem Text UI (Blackbox) Intent/Responsibility This subsystem implements the communication with a client (for example, a graphical user interface) using the text-based XBoard protocol (→ Decision V.9.1). It reads commands from standard input, checks them against the rules of the game and converts them for the Engine. Responses from the Engine (especially the moves) will be accepted by the subsystem as events, formatted according to the protocol and returned via standard output.</description>
    </item>
    
    <item>
      <title>Connection</title>
      <link>http://example.org/04_solutionstrategy/03_connection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/04_solutionstrategy/03_connection/</guid>
      <description>4.4 The Connection of the Engine DokChess has no graphical user interface. Instead communication takes place via standard input and output. The text-based XBoard acts as a communication protocol (→ Decision 9.1 &amp;ldquo;How does the engine communicate with the outside world?&amp;rdquo;). You can use DokChess interactively with the command line if you know the XBoard commands and are able to interpret the engine responses (→ Concept 8.3 User Interface). See image below:</description>
    </item>
    
    <item>
      <title>Rules</title>
      <link>http://example.org/05_buildingblockview/03_rules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/03_rules/</guid>
      <description>5.3	Subsystem Rules (Blackbox) Intent/Responsibility This subsystem accounts for the rules of chess according to the International Chess Federation (FIDE). It determines all valid moves for a position and decides whether it is a check, a checkmate or a stalemate.
Interfaces The subsystem provides its functionality via the Java interface
org.dokchess.rules.ChessRules.
Default implementation of the interface is class
org.dokchess.rules.DefaultChessRules.
Fig.: Interface ChessRules
Method Short description getStartingPosition Returns the starting position of the game.</description>
    </item>
    
    <item>
      <title>Engine</title>
      <link>http://example.org/05_buildingblockview/04_engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/04_engine/</guid>
      <description>5.4 Engine (Blackbox) Intent/Responsibility This subsystem contains the determination of a next move starting from a game position. The position is given from outside. The engine itself is stateful and always plays one game at the same time. The default implementation needs an implementation of the game rules to work. An opening library, however, is optional.
Interfaces The Engine subsystem provides its functionality via the Java interface
org.dokchess.engine.Engine.
Default implementation is the class</description>
    </item>
    
    <item>
      <title>Opening</title>
      <link>http://example.org/05_buildingblockview/05_opening/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/05_opening/</guid>
      <description>5.5 Subsystem Opening (Blackbox) Intent/Responsibility This subsystem provides opening libraries and implements the Polyglot opening book format. This format is currently the only one available, which is not proprietary. Corresponding book files and associated tools are freely available on the Internet.
Interfaces The Opening subsystem provides its functionality via the Java interface
org.dokchess.opening.OpeningLibrary.
The class org.dokchess.opening.polyglot.PolyglotOpeningBook provides one possible implementation.
Fig.: Schnittstelle Eroeffnungsbibliothek, Implementierung PolyglotOpeningBook
Method Short description lookUpMove Returns a standard move for the specified position from the library, or null.</description>
    </item>
    
    <item>
      <title>Requirements Overview</title>
      <link>http://example.org/01_introduction/01_requirements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/01_introduction/01_requirements/</guid>
      <description>1.1 Requirements Overview What is &amp;ldquo;applicationname&amp;rdquo; ? xxx. yyy zzz Uygulama mimarisi hakkında temel bilgiler
Essential Features aaa bbb ccc Uygulamanın öne çıkan özellikleri</description>
    </item>
    
    <item>
      <title>Terms</title>
      <link>http://example.org/12_glossary/02_terms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/12_glossary/02_terms/</guid>
      <description>Term Definition 50 move rule A rule in chess, which states that a player can claim a draw after 50 moves whilst in the meantime no pawn has been moved and no piece has been taken. Alpha-beta pruning Significant improvement of the Minimax algorithm, in which parts of the search tree can be &amp;ldquo;cut off&amp;rdquo; without coming to a different resulting move. Castling A special move in chess where both the players&amp;rsquo;s king and one the rooks are moved.</description>
    </item>
    
    <item>
      <title>Level 2: Engine</title>
      <link>http://example.org/05_buildingblockview/06_level_2_engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/06_level_2_engine/</guid>
      <description>5.6 Level 2: Engine (Whitebox) The engine breaks down in modules Search and (position) Evaluation as shown in the following diagram. If available, the determination of the move is initially delegated to an opening book. Only if the book does not provide a standard move Search is used.
Fig.: Engine, building block view, level 2
Module Short description Search Determines the optimal move for a position under certain conditions. Evaluation Evaluates a position from an opponent&amp;rsquo;s perspective.</description>
    </item>
    
    <item>
      <title>Quality Goals</title>
      <link>http://example.org/01_introduction/02_qualitygoals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/01_introduction/02_qualitygoals/</guid>
      <description>1.2 Quality Goals The following table describes the key quality objectives of XXX. The order of the goals gives you a rough idea of their importance.
Quality Goal Motivation/description a b a b a b a b The quality scenarios in section 10 detail these goals and serve to evaluate their achievement.</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>http://example.org/05_buildingblockview/07_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/07_search/</guid>
      <description>5.7 Search (Blackbox) Intent/Responsibility The module determines the optimal move for a position under certain conditions. In the game of chess an optimal move always exists, theoretically. The high number of possible moves and the resulting incredible mass of game situations to consider makes it impossible to determine it in practice. Common algorithms like the Minimax therefore explore the &amp;ldquo;game tree&amp;rdquo; only up to a certain depth.
Interfaces The module provides its functionality via the Java interface</description>
    </item>
    
    <item>
      <title>Stakeholders</title>
      <link>http://example.org/01_introduction/03_stakeholders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/01_introduction/03_stakeholders/</guid>
      <description>1.3 Stakeholders The following table illustrates the stakeholders of XXXX and their respective intentions.
Uygulama paydaşları ve durumları aşağıdaki tabloya yazılacak.
Who? Matters and concern Software Architects item1item2 Developers item1item2 DevOps Engineer item1item2 </description>
    </item>
    
    <item>
      <title>Evaluation</title>
      <link>http://example.org/05_buildingblockview/08_evaluation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/05_buildingblockview/08_evaluation/</guid>
      <description>5.8 Evaluation (Blackbox) Intent/Responsibility The module evaluates a position from an opponent&amp;rsquo;s perspective. Result is a number where 0 is a balanced situation. A positive number describes an advantage for the player, a negative one a drawback. The higher the number, the greater the advantage or disadvantage. The module makes it therefore possible to compare positions with each other.
Interfaces The Evaluation module provides its functionality via the Java interface</description>
    </item>
    
  </channel>
</rss>
