[
{
	"uri": "http://example.org/00_overview/",
	"title": "Architectural Overview",
	"tags": [],
	"description": "An architectural overview for a Chess Engine. Structured according to arc42.",
	"content": " Bu template mimari review dökümanlarında consultancy servise uygun olarak düzenlenecek.\n\u0026ldquo;Varsa önemli not buraya konumlanabilir.\u0026rdquo;\nProjenin ismi, genel açıklaması ve döküman içeriği Uygulamanın kısa bir özeti bu kısımda yer alacak.\nAyrıca bu dökümanın içeriğine ilişkin genel bilgi verilecek.\n"
},
{
	"uri": "http://example.org/03_context/01_business/",
	"title": "Business Context",
	"tags": [],
	"description": "",
	"content": "3.1 Business Context Fig.: Business Context of DokChess Human opponent (user) Chess is played between two opponents, who move their pieces in turn. DokChess takes the role of one of the opponents, and competes against a human opponent. For this purpose, the two need to communicate, e.g. about their moves, or draw offers.\nComputer opponent (external system) As an alternative to a human opponent DokChess can also compete with a different engine. The requirements related to the exchange of information are the same.\nOpenings (external system) About the opening, which is the early stage of a game, extensive knowledge exists in chess literature. This knowledge is partly free and partly also commercially available in the form of libraries and databases. Within DokChess no such library is created. Optionally an external system is connected instead in order to permit a knowledge based play in the early stages, as expected by human players.\nEndgames (external system) If just a very few pieces are left on the board (e.g. only the two kings and a queen), endgame libraries can be used analogously to opening libraries. For any position with this piece constellation these libraries include the statement whether a position is won, drawn or lost, and if possible the necessary winning move.\nWithin DokChess no such library is created. Optionally an external system is connected instead in order to bring clearly won games home safely, or to use the knowledge from the libraries for analysis and position evaluation.\n"
},
{
	"uri": "http://example.org/08_concepts/01_dependencies/",
	"title": "Dependencies",
	"tags": [],
	"description": "",
	"content": "8.1 Dependencies Between Modules DokChess invites developers to experiment and to extend the engine (→ 1.1 Requirements Overview). In order to do so, the modules are loosely coupled. DokChess modules are implementations of Java interfaces. Java classes that require parts signal this with appropriate methods set«Module»(«Interface» \u0026hellip;). They don\u0026rsquo;t take care of resolving a dependency, for instance, by using a factory. Instead, the client resolves the dependencies by creating suitable implementations with new and putting them together with setter methods (also known as Dependency Injection, short DI).\nInterfaces and DI enable alternative implementations within DokChess. Adding functionality with the help of the decorator pattern (Gamma+94) is possible as well. Furthermore, aspect-oriented programming (AOP) solutions, which rely on Java dynamic proxies, are applicable interfaces. Plus, this handling of dependencies positively affects testability (→ 8.7 Testability).\nDokChess abstains from the use of a concrete DI framework. The modules are hard-wired in the code, however only in unit tests and glue code (for example, the main class). No annotation driven configuration is present in the code.\nThis gives adventurous developers free choice regarding a specific DI implementation. Since the Java modules are pure POJOs (Plain Old Java objects), nothing prevents configuration with the Spring Framework for example or CDI (Contexts and Dependency Injection for the Java EE Platform).\n"
},
{
	"uri": "http://example.org/11_risks/01_frontend/",
	"title": "Frontend Connection",
	"tags": [],
	"description": "",
	"content": "11.1 Risk: Connecting to the Frontend fails There is no knowledge about connecting an engine to an existing chess frontend. Available open source engines are programmed in C and are delivered as executable programs (*.exe). Since DokChess is developed in Java, they are of limited use as examples. Nothing is known in the project about chess communication protocols.\nIf it is not possible to make a working connection, the solution can not be used with existing frontends. This not only lacks an important feature (→ 1.1 Requirements Overview), but also makes the solution as a whole, especially as a case study, untrustworthy.\nContingency Planning A simple textual user interface could be implemented in order to interact with the engine. The implementation of a DokChess specific graphical front end would be costly (→ 11.2 \u0026ldquo;Effort of Implementation\u0026rdquo;).\nRisk Mitigation Through an early proof of concept, certainty is achieved as soon as possible here.\n"
},
{
	"uri": "http://example.org/09_decisions/01_connectivity/",
	"title": "Frontend Connectivity",
	"tags": [],
	"description": "How Does the Engine Communicate with the Outside World?",
	"content": "9.1 How Does the Engine Communicate with the Outside World? Problem Background As a central requirement DokChess must work together with existing chess frontends. How do we connect them?\nA whole series of graphical user interfaces are available for playing against chess programs. Moreover, there are software solutions with a larger scope for chess enthusiasts. In addition to the game \u0026ldquo;Human vs. Machine\u0026rdquo;, they offer more functionality, such as analyzing games. Over time, new chess programs will be released \u0026ndash; and others will possibly disappear from the market.\nDepending on how the connection with such programs is realized, DokChess can or can not communicate with specific frontend clients. Thus, the issue affects DokChess\u0026rsquo; interoperability with existing chess software and its adaptability to future chess software.\nInfluences on the Decision Constraints Operation of the frontend at least on Windows desktop operating systems Support for freely available frontends Favoring established (chess) standards (→ 2.3 Conventions) Significantly Affected Quality Attributes (→ 1.2 Quality Goals) Quality Goal: Using existing frontends (Interoperability) Quality Goal: Platform appealing to experiments (Changeability) Adaptability (to future chess software) Affected Risks Connecting to the Frontend fails (→ 11.1) Assumptions The investigation of just a few available frontends leads to all interesting integration options. Considered Alternatives In early 2011, the following chess frontends were investigated:\nArena Chess GUI (available for free, runs on Windows) Fritz for Fun (commercially provided by ChessBase GmbH, runs on Windows) Winboard / XBoard (Open source, runs on Windows, Mac OS X, *nix) As a result, two communication protocols have been identified as options:\nOption 1: UCI Protocol (universal chess interface), see hier Option 2: XBoard Protocol (also known as Winboard and as Chess Engine Communication Protocol), see hier Neither of the two protocols are formally specified, but both are publicly documented.\nBoth protocols are text-based, and communication between the frontend and the engine is via stdin/stdout. In both cases the front end starts the engine in a separate process.\nThe following Table compares the three investigated frontends to their implemented protocols:\nArena 3 Fritz for fun Winboard / XBoard UCI Yes Yes - XBoard-Protocol Yes - Yes Table: Protocols and Frontends Decision Under the given constraints, the quality goals can generally be achieved with both options. Depending on which protocol is implemented, different front ends are supported.\nThe decision in favor of the XBoard protocol was made in early 2011. The structure of DokChess allows us to add alternative communication protocols (UCI or other) without having to change the engine itself for this, see dependencies in the building block view (→ 5.1).\nThe preferred front end for Windows is Arena. It is freely available and tops the functionality of WinBoard. It has good debugging facilities. For example, it can present the communication between the frontend and the engine live in a window. Arena supports both protocols.\nBy opting for the XBoard protocol, other operating systems (in addition to Windows, especially Mac OS X and Linux) are also supported with freely available frontends (see the preceding table). As such, a larger circle of interested developers may use the engine, which was finally essential.\n"
},
{
	"uri": "http://example.org/01_introduction/",
	"title": "Introduction and Goals",
	"tags": [],
	"description": "This section introduces the task and outlines the objectives pursued by DokChess.",
	"content": "Section 1 Introduction and Goals This section introduces the task and outlines the objectives pursued by XXXX.\n"
},
{
	"uri": "http://example.org/02_constraints/01_technical/",
	"title": "Technical",
	"tags": [],
	"description": "",
	"content": "2.1 Technical Constraints Teknik kısıtlamalar\nConstraint Background and / or motivation Moderate hardware equipment Operating XXX on a standard notebook in order to show the software in the context of workshops and conferences on such a device. Operating on Windows desktop operating systems Standard equipment for notebooks of oose employees at the time of outlining the solution. High distribution of these operating systems at potentially interested parties (audience at conference talks, participants in trainings). Support for other operating systems (most notably Linux and Mac OS X) is desirable, but not mandatory. Implementation in Java Usage as an example in Java-centered trainings and Java conferences. Development with Java SE version 6 (DokChess 1.0), later Java SE 7. The engine should also run in newer Java versions, when available. Third-party software freely available If third-party software is involved (for example, a graphical front end), this should ideally be freely available and free of charge. This way the threshold to use it is kept low. "
},
{
	"uri": "http://example.org/10_qualityrequirements/01_utilitytree/",
	"title": "Utility Tree",
	"tags": [],
	"description": "",
	"content": "10.1 Utility Tree The following diagram gives an overview of the relevant quality attributes and their associated scenarios. The quality goals are also included in the figure, and each refers to the scenarios that illustrate them.\n"
},
{
	"uri": "http://example.org/02_constraints/",
	"title": "Constraints",
	"tags": [],
	"description": "At the beginning of the project various constraints had to be respected within the design of XXXX. They still affect the solution.",
	"content": "Section 2 Constraints At the beginning of the project various constraints had to be respected within the design of XXXXX. They still affect the solution. This section represents these restrictions and explains \u0026ndash; where necessary \u0026ndash; their motivations.\n"
},
{
	"uri": "http://example.org/03_context/02_deployment/",
	"title": "Deployment Context",
	"tags": [],
	"description": "",
	"content": "3.2 Deployment Context Fig.: Technical communication of DokChess with third parties XBoard client (external system) A human player is connected to DokChess with a graphical front-end. The development of such is not part of DokChess. Each graphical frontend can be used instead, if it supports the so-called XBoard protocol. These include Xboard (or Winboard on Windows), Arena and Aquarium.\nPolyglot Opening Book (external system) Polyglot Opening Book is a binary file format for opening libraries. DokChess allows the optional connection of such books. Only read access is used.\nOn endgames The implementation of a connection to endgame databases (such as Nalimov Endgame tablebases) has been dropped due to the effort of implementation (|→ Risk 11.2](/en/11_risks/02_effort/) Effort of implementation). The design, however, is open to appropriate extensions.\n"
},
{
	"uri": "http://example.org/08_concepts/02_domainmodel/",
	"title": "Domain Model",
	"tags": [],
	"description": "",
	"content": "8.2 Chess Domain Model \u0026ldquo;The game of chess is played between two opponents who move their pieces on a square board called a ‘chessboard’.\u0026rdquo;\u0026quot;\nfrom the FIDE Laws of Chess\nThe different modules of DokChess exchange chess-specific data. This includes the game situation on the chessboard (position) for instance, as well as opponent\u0026rsquo;s and own moves. All interfaces use the same domain objects as call and return parameters.\nThis section contains a brief overview of these data structures and their relationships. All the classes and enumeration types (enums) are located in the org.dokchess.domain package. See the source documentation (javadoc) for details.\nA chess piece is characterized by colour (black or white) and type (king, queen, and so on). In the DokChess domain model, a piece does not know its location on the board. The Piece class is immutable, and so are all other domain classes.\nFig.: A piece has a colour and a type\nA chessboard consists of 8 x 8 squares, which are arranged in 8 rows called ranks (1-8) and 8 columns called files (a-h). The Square class describes one of these. Since a square can be occupied by only one piece, source and target squares are sufficient to specify a move (the Move class). The only exception is the promotion of a pawn on the opponent\u0026rsquo;s baseline. Here, the player decides which piece type they want to convert the pawn to (typically, but not necessarily, a queen). Castling moves are represented as king moves over two squares in the corresponding direction. The additional attributes for the moving piece and whether the move is a capture are useful for the analysis tasks of the engine.\nFig.: A move from square to square\nThe Position class describes the current situation on the board. In particular, these are the piece locations on the board, which are internally represented as a two-dimensional array (8 x 8). If a square is not occupied, null is stored in the array. To complete the game situation, the Position class includes information about which side moves next, which castlings are still possible (if any), and whether capturing en passant is allowed.\nFig.: A position describes a game state\nThe Position class is immutable as well. Therefore, the performMove() method returns a new position with the modified game situation (→ decision V.9.2 \u0026ldquo;Are position objects changeable or not?\u0026rdquo;).\n"
},
{
	"uri": "http://example.org/11_risks/02_effort/",
	"title": "Effort",
	"tags": [],
	"description": "",
	"content": "11.2 Risk: Implementation effort too high There is no experience with chess programming. Simultaneously, the rules that are to be implemented completely (→ 1.1 Requirements Overview) are extensive and complicated. The different pieces move differently, and there are special rules such as stalemate and promotion. In the case of castling and en passant, the move history, and not only the current situation on the board, is relevant.\nThe programming of the algorithms is also non-trivial. For the connection of opening libraries and endgame databases, extensive research is required.\nThe implementation of DokChess runs as a hobby alongside, within the spare time. It is unclear whether this is sufficient to present ambitious results within schedule (→ 2.2 Organizational Constraints).\nContingency Planning If there is no runnable version for the conference sessions in March and September 2011, a live demonstration could be omitted. The free evening talk at oose in March could even be canceled completely (which could negatively affect the reputation).\nRisk Mitigation In order to reduce effort, the following rules are not implemented at first:\n50 moves rule threefold repetition Their absence has little consequence with respect to the playing strength, and consequence no consequence with respect to the correctness of the engine.\nConnecting opening libraries and endgame databases has low priority and and takes a back seat at first.\n"
},
{
	"uri": "http://example.org/02_constraints/02_organizational/",
	"title": "Organizational",
	"tags": [],
	"description": "",
	"content": "2.2 Organizational Constraints Organizasyonel kısıtlamalar\nConstraint Background and / or motivation Team Stefan Zörner, supported by colleagues, friends and interested workshop or training participants Schedule Start of development in December 2010, first running prototype March 2011 (evening talk at oose in Hamburg), presentable version May 2011 (talk at JAX conference in Mayence, Germany). Completion of Version 1.0: February 2012 (Deadline book manuscript for 1st edition). Process model Risk driven development, iterative and incremental. To describe the architecture arc42 is used. An architecture documentation structured according to this template is a key project result. Development Tools Design with pen and paper, in addition Enterprise Architect. Work results for architecture documentation collected in Confluence Wiki. Java source code created in Eclipse or IntelliJ. However, the software can be built only with Gradle, i.e. without an IDE. Configuration and version management At the beginning (Version 1.0) Subversion at SourceForge, later Git at GitHub. Test tools and test processes JUnit with annotation style both for correctness and integration testing and for compliance with efficiency targets. Release as Open Source The source code of the solution, or at least parts, made available as open source. License: GNU General Public License version 3.0 (GPLv3). Hosted at GitHub. "
},
{
	"uri": "http://example.org/09_decisions/02_positionobjects/",
	"title": "Position Objects",
	"tags": [],
	"description": "Are Position Objects Changeable or Not?",
	"content": "9.2 Are Position Objects Changeable or Not? Problem Background For various DokChess modules, game situations on the chess board (so-called positions) must be provided and exchanged between them. Do we make the associated data structure changeable or unchangeable (immutable)?\nDuring a game, the position changes when the opposing players move their pieces. In addition, the engine performs possible moves in its analysis, tries to counter the moves of the opponent, evaluates the outcoming positions, and then discards moves. The result is a tree that contains many thousands of different positions, depending on the search depth.\nDepending on whether the position is immutable as a data structure or not, algorithms are easier or more difficult to implement, and its execution is efficient in a different way.\nAll modules depend on the position interface. A subsequent change would affect all of DokChess.\nInfluences on the Decision Constraints (→ 2.1 Technical Constraints) Implementation in Java Moderate hardware equipment Significantly Affected Quality Attributes (→ 1.2 Quality Goals) Quality Goal: Platform appealing to experiments (Changeability) Quality Goal: Acceptable playing strength (Attractiveness) Quality Goal: Quick response to opponent\u0026rsquo;s moves (Effizienz) Affected Risks Implementation effort too high (→ 11.2) Achieving the playing strength fails (→ 11.3) Assumptions It is possible to implement a data structure with a fine-grained object model (that is, classes such as Piece and Move) that is efficient enough to provide the required playing strength within an adequate response time. In the future, concurrent algorithms should be implemented with the data structure as well. Considered Alternatives The starting point is domain-driven classes for square, piece and move (→ 8.2 Chess Domain Model). These classes are realized immutable as value objects (the e4 field always remains e4 after it\u0026rsquo;s construction).\nFor the position, two alternatives are considered:\nOption (1): The position is changeable. Individual methods of the interface, for example, performing moves or taking them back, change the object state. // Pseudocode Position p = new Position(); // starting position, white side to move p.performMove(e2e4); // king's pawn advances two squares, black to move p.takeBackLastMove() // starting position again ... Option (2): The position is unchangeable (\u0026ldquo;immutable\u0026rdquo;). That means a method for performing a move provides the new position (it copies the old one, then the move happens) as another immutable object as the result. Position p = new Position(); newPosition = p.performMove(e2e4); // p keeps unchanged ... The following table summarizes the strengths and weaknesses of the two options, they are explained below.\n(1) changeable (2) unchangeable Implementation effort (-) higher (+) lower Efficiency (memory consumption) (+) more economical (-) higher demand Efficiency (time behaviour) (o) neutral (-) worse Suitability for concurrent algorithms (-) bad (+) good Table: strengths and weaknesses of the two options Option (1): The Position is Changeable (+) Positive Arguments\nThe position with its extensive state is not copied in each move. This saves memory and CPU time, and it treats the garbage collector with care. For analysis algorithms, however, it is necessary to implement functionality that takes back the effect of moves (\u0026ldquo;undo\u0026rdquo;). This Undo also takes time, hence the neutral rating (o) for the time behavior.\n(-) Negative Arguments\nThe implementation of an Undo-functionality is complex. Not only does it have to set up captured pieces back on the board, the castling rule and en passant require special treatment as well. The Gamma+94 Command pattern suggests itself as an option. The use of that pattern within algorithms is also more complex because the latter must explicitly call methods to take back the moves.\nFinally, changeable state has drawbacks related to concurrency.\nOption (2): The Position is Unchangeable (+) Positive Arguments\nWhen you perform a move, the position is copied. It does not change the original. This eliminates the implementation of move reversal (Undo). Clients can simply store the old position as a value. This saves effort in the implementation compared to option (1).\nImmutable objects offer significant advantages in concurrent algorithms.\n(-) Negative Arguments\nCopying the state for each new position takes time. When analyzing situations, it covers many positions, which can take a lot of time.\nBeyond that, copying the state for each new position costs memory. The implementation of search algorithms with backtracking at least prevents complete game trees from ending up on the heap. Nevertheless, more memory is required, and the garbage collector has more work to do.\nBoth points have a negative effect on efficiency.\nDecision The decision for the unchangeable position (option 2) was made in early 2011 due to the advantages in terms of ease of implementation and the prospect of exploiting concurrency. All the disadvantages of option 2 are related to efficiency.\nDue to the risk of failing to achieve the objectives with respect to the playing strength in an acceptable computing time (attractiveness, efficiency), prototypes of both versions have been implemented and compared in a mate search (Checkmate in three moves) with the minimax algorithm. With option 2, the search took 30% longer, assuming you implement copying efficiently. But this option met the constraints still well.\nFurther optimization options could reduce the efficiency disadvantage compared with option 1, if necessary. But they have not been implemented in the first run in order to keep the implementation simple.\nThese options included the use of multiple processors/cores with concurrent algorithms. In the meantime (with DokChess 2.0), this was illustrated with a parallel minimax example.\n"
},
{
	"uri": "http://example.org/10_qualityrequirements/02_qualityscenarios/",
	"title": "Quality Scenarios",
	"tags": [],
	"description": "",
	"content": "10.2 Quality Scenarios The initial letters of the identifiers (IDs) of the scenarios in the following table each stand for the parent quality attribute (in German), E for efficiency, for instance. These identifiers are also used in the quality tree. The scenarios cannot always be clearly assigned to one characteristic. Therefore, they sometimes appear several times in the quality tree.\nID Scenario W01 A person with basic knowledge of UML and chess looks for an introduction to the DokChess architecture. He or she gets the idea of the solution strategy and the essential design within 15 minutes W02 An architect who wishes to apply arc42 searches for a concrete example for an arbitrary section of the template. He or she finds the relevant content immediately in the documentation. W03 An experienced Java developer searches for the implementation of a module described in the design. He or she finds it in the source code without detours or help from others. W04 A developer implements a new position evaluation. He or she integrates it into the existing strategies without modification and without compilation of existing source code. W05 A developer implements a piece-centric bitboard representation of the game situation. The effort (which includes replacing the existing, square-centric representation) is lower than one person week. K01 A user plans to use DokChess with a frontend that supports a communication protocol that\u0026rsquo;s already implemented by the solution. The integration does not require any programming effort, the configuration with the front end is carried out and tested within 10 minutes. F01 In a game situation, the engine has one or more rule-compliant moves to choose from. It plays one of them. F02 A weak player is in a game against the engine. The player moves a piece to an unguarded position which is being attacked by the engine. The engine consequently takes the dropped piece. F03 Within a chess match, a knight fork to gain the queen or a rook arises for the engine. The engine gains the queen (or the rook) in exchange for the knight. F04 Within a chess match, a mate in two unfolds to the engine. The engine moves safely to win the game. E01 During the game, the engine responds to the move of the opponent with its own move within 5 seconds. E02 An engine integrated in a graphical frontend plays as black, and the human player begins. The engine responds within 10 seconds with its first move, and the user gets a message that the engine \u0026ldquo;thinks\u0026rdquo; within 5 seconds. Z01 During the game, the engine receives an invalid move. The engine rejects this move and allows the input of another move thereafter and plays on in an error-free way. Z02 The engine receives an illegal position to start the game. The engine recognizes the situation and quits the game. P01 A Java programmer plans to use a chess frontend that allows the integration of engines, but does not support any of the protocols implemented by DokChess. The new protocol can be implemented without changing the existing code, and the engine can then be integrated as usual. "
},
{
	"uri": "http://example.org/03_context/",
	"title": "Context",
	"tags": [],
	"description": "This section describes the environment of DokChess. Who are its users, and with which other systems does it interact with.",
	"content": "Section 3 Context This section describes the environment of DokChess. Who are its users, and with which other systems does it interact with.\n"
},
{
	"uri": "http://example.org/02_constraints/03_conventions/",
	"title": "Conventions",
	"tags": [],
	"description": "",
	"content": "2.3 Conventions Dokümanttasyon vs.\nConvention Background and / or motivation Architecture documentation Terminology and structure according to the arc42 template, version 6.0 Coding guidelines for Java Java coding conventions of Sun / Oracle, checked using CheckStyle Chess-specific file formats Use of established standards for chess-specific notations and exchange formats within the solution. Topics: moves, positions, games, openings, \u0026hellip; Never develop own formats here. Principle: Favour open standards over proprietary formats (which commercial programs may use). "
},
{
	"uri": "http://example.org/11_risks/03_playingstrength/",
	"title": "Playing Strength",
	"tags": [],
	"description": "",
	"content": "11.3 Risk: Achieving the playing strength fails The quality goals demand both an acceptable playing strength and a simple, accessible solution. In addition, there are requirements with respect to efficiency. It is uncertain whether the planned Java solution with an object-oriented domain model and simple move selection can achieve these competing goals.\nThe risk manifests itself through too bad playing strength, too long waiting times or both. This would be particularly unpleasant for live performances in lectures, as the solution is not perceived as such by the listeners (but as a toy).\nIt is unclear at what point a playing strength is considered to be unreasonably weak.\nContingency Planning In conference talks, parts of the live demonstration could be omitted. If necessary, we could show games played before.\nRisk Mitigation Suitable scenarios (examples → 10. \u0026ldquo;Quality Scenarios\u0026rdquo;) concretize the quality goals. With the help of chess literature (chess problems to be precise) we develop test cases (unit testing), which specify what playing strength can be expected. Thus at least we detect early where the engine stands.\n"
},
{
	"uri": "http://example.org/08_concepts/03_userinterface/",
	"title": "User Interface",
	"tags": [],
	"description": "",
	"content": "8.3\tUser Interface DokChess itself has no graphical user interface. It interacts via the XBoard protocol with the outside world (→ Decision 9.1 \u0026ldquo;How does the engine communicate with the outside world?\u0026rdquo;).\nThe XBoard protocol is text-based. If you have mastered the main commands (see Figure \u0026hellip;) starting DokChess in a command line (Unix shell, Windows command prompt, \u0026hellip;) enables you to interact with the engine. The table below shows a sample dialog, all commands are terminated with a new line). By default the engine plays black. You can change this with the \u0026ldquo;white\u0026rdquo; command of XBoard.\nClient → DokChess DokChess → Client Comments xboard client wants to use the XBoard-Protocol (required since engines partly understand other, sometimes even multiple protocols) (new line) protover 2 protocol version 2 feature done=1 line by line notification of additional features of the engine (here: none) e2e4 white plays pawn e2-e42 move b8c6 black (DokChess) plays knight b8-c6 quit client ends the game (DokChess terminates) Table: Example communication bewtween a client and DokChess (XBoard)\nMann+2009 describes the protocol itself in detail. In DokChess the Text UI subsystem is responsible for the protocol implementation (→ Building Block View 5.2).\nA more typical use of DokChess is a graphical chess frontend like Arena (see image below). It accepts the moves of the opponent in a comfortable interface, passes them to DokChess in the form of XBoard commands like in the table above (column \u0026ldquo;Client → DokChess\u0026rdquo;) and translates the answers (column \u0026ldquo;DokChess → Client\u0026rdquo;) graphically.\nFig.: DokChess combined with the Arena chess frontend under Windows\n"
},
{
	"uri": "http://example.org/04_solutionstrategy/",
	"title": "Solution Strategy",
	"tags": [],
	"description": "This section contains a highly compact architecture overview.",
	"content": "Section 4 Solution Strategy This section contains a highly compact architecture overview. A contrast of the most important goals and approaches.\n"
},
{
	"uri": "http://example.org/08_concepts/04_validation/",
	"title": "Validation",
	"tags": [],
	"description": "",
	"content": "8.4 Plausibility Checks and Validation In simple terms, DokChess is an algorithm. It responds to moves of the opponent with its own moves. Two channels are relevant for input validation:\nthe XBoard protocol for interactive user input from the opponent opening libraries in the form of files Input that comes through the XBoard protocol is parsed from the corresponding subsystem. In case of unknown or unimplemented commands DokChess reports the XBoard command \u0026ldquo;Error\u0026rdquo; back to the client.\nIn case of move commands DokChess checks using the rules subsystem whether the move is allowed or not. In case of illegal moves DokChess reports the XBoard command \u0026ldquo;Illegal move\u0026rdquo; back to the client. When using a graphical front end, this case should not occur, since these typically accept only valid moves. The case is likely relevant when interacting via command line (→ 8.3 User Interface).\nInputs that come through the XBoard protocol are parsed from the corresponding subsystem. For unknown or unimplemented commands DokChess reports the XBoard command \u0026ldquo;Error\u0026rdquo; back to the client. When setting up a position DokChess checks the compliance with the protocol, but not whether the position is permitted. In extreme cases (e.g. if no kings are present on the board), the engine subsystem may raise an error during the game.\nFor opening libraries DokChess only checks whether it can open and read the file. In case of a failure (e.g. file not found) it raises an exception (→ 8.5 Exception and Error Handling) \u0026ldquo;Exception and Error Handling\u0026rdquo;). While reading the file the opening subsystem responds with a runtime error to recognized problems (for example, invalid file format). However, the content of the library itself is not checked. For example, if invalid moves are stored for a position it is not recognized. The user is responsible for the quality of the library (see → 3. Context. In extreme cases, the engine may respond with an illegal move.\n"
},
{
	"uri": "http://example.org/05_buildingblockview/",
	"title": "Building Block View",
	"tags": [],
	"description": "This section describes the decomposition of DokChess into modules. These are also reflected in the package structure of the Java source code.",
	"content": "Section 5 Building Block View This section describes the decomposition of DokChess into modules. These are also reflected in the package structure of the Java source code. In DokChess we call modules of the first decomposition level subsystems. The → Building Block View, Level 1 presents them including their interfaces.\nFor the subsystem Engine this overview also includes a more detailed breakdown into → Level 2.\n"
},
{
	"uri": "http://example.org/08_concepts/05_errorhandling/",
	"title": "Error Handling",
	"tags": [],
	"description": "",
	"content": "8.5 Exception and Error Handling DokChess has no own user interface. Therefore it must indicate problems to the outside world.\nAll DokChess subsystem methods throw Runtime Exceptions. In addition in case of the Engine subsystem error messages (onError) may occur during an asynchronous search. Your own extensions (for example a custom search) must be implemented accordingly. Checked exceptions (e.g. java.io.IOException) need to be wrapped in Runtime Exceptions.\nThe javadoc of methods and constructors in question shows the rare cases where exceptions are expected in DokChess. Trouble reading an opening book file, or when trying move calculation within the engine at an invalid position (if identified). All other exceptions would be programming errors (please report them under https://github.com/DokChess/).\nThe Text UI subsystem catches all exceptions and communicates them via the XBoard protocol outwards (command \u0026ldquo;tellusererror\u0026rdquo;). A graphical front-end usually visualizes them in an error dialog or alert box. The image below depicts that for the chess frontend Arena.\nFig.: An error dialog in Arena\nDokChess continues to work \u0026ldquo;normally\u0026rdquo;. The client decides whether proceeding in this specific situation makes sense. For example, it could continue to play without an opening book.\n"
},
{
	"uri": "http://example.org/08_concepts/06_logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "8.6 Logging and Tracing For improvements and extensions the analysis capabilities provided by DokChess are of note, particularly in case of on error.\nThe DokChess functionality itself can be checked easily with unit tests. This is particularly true for the correct implementation of the game rules and for the game play of the engine (→ 8.7 Testability). It holds true for your own extensions in this area as well.\nTherefore there is no fine-grained logging output within DokChess. Solutions like SLF4J are not present. In this way we avoid a dependency to an external library and the source code is not polluted by this aspect at all.\nFor the communication between the client and DokChess via the XBoard protocol \u0026ndash; in addition to interactive operation via a shell (→ 8.3 User Interface) \u0026ndash; the client may monitor the conversation. Common chess frontends permit this by writing log files and/or a simultaneous display of a log window during the game. The image below shows this functionality within Arena.\nFig.: Log and debug window for XBoard Protocol in Arena\nIf the engine blocks and it is unclear what went on on the XBoard protocol, such tools are simply invaluable. Due to the availability of this feature a communication protocol tracing was not implemented within DokChess at all.\n"
},
{
	"uri": "http://example.org/06_runtimeview/",
	"title": "Runtime View",
	"tags": [],
	"description": "In contrast to the static building block view, this section visualizes dynamic aspects.",
	"content": "Section 6 Runtime View In contrast to the static building block view, this section visualizes dynamic aspects. How do the pieces play together?\n"
},
{
	"uri": "http://example.org/07_deploymentview/",
	"title": "Deployment View",
	"tags": [],
	"description": "This view describes the operation of DokChess.",
	"content": "Section 7 Deployment View This view describes the operation of DokChess. As a Java program, it is relatively undemanding if you want to use it only on the command line. However, this is inconvenient and requires a physical chess board with coordinates, if the user cannot play blindfolded. Therefore, here is an explanation of how to configure DokChess in conjunction with a graphical frontend.\n"
},
{
	"uri": "http://example.org/08_concepts/07_testability/",
	"title": "Testability",
	"tags": [],
	"description": "",
	"content": "8.7 Testability Nothing is more embarrassing for an engine than an illegal move.\nThe functionality of the individual modules of DokChess is ensured by extensive unit tests. You find a folder src/test next to src/main, where the Java source code of the modules is stored. It mirrors the package structure, and in the corresponding packages unit tests for the classes realized with JUnit 4.\nStandard unit testing, which examine the individual classes, are named as the class itself with suffix Test. In addition, there are tests that examine the interaction of modules, and in extreme cases the whole system. With the help of such tests, the correct playing of DokChess is checked. More complex, long-running integration tests are below src/integTest. This includes playing entire games.\nIn many tests positions must be provided as call parameters. Here the Forsyth-Edwards Notation (FEN in short) is used. This notation allows the specification of a complete game situation as a compact string without a line break and is therefore perfect for use in automated tests.\nThe starting position in FEN for example is denoted:\n\u0026quot;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\u0026quot; Lowercase letters stand for black, uppercase for white pieces. For the piece types the English names (r for rook, p for pawn \u0026hellip;) are used.\nFig.: Sample position\nThe game situation in the picture above with white before the 79th move, with 30 half-moves long no piece was captured and no pawn was moved, looks like this in FEN\n\u0026quot;6r1/6pp/7r/1B5K/1P3k2/N7/3R4/8 w - - 30 79\u0026quot; and reads \u0026ldquo;6 squares free, black rook, square free, new rank \u0026hellip;\u0026rdquo;.\nDetails about the notation can be found for example at Wikipedia. The Position class has a constructor that accepts a string in FEN. The toString method of this class also provides FEN.\nIn addition to tests for correct functionality, it is also checked whether the required response times for exemplary game situations can be met. This is done with the @Test annotation and its timeout parameters. The success of these tests depends on the hardware used.\n"
},
{
	"uri": "http://example.org/08_concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "This section describes general structures and system-wide aspects.",
	"content": "Section 8 Technical and Crosscutting Concepts This section describes general structures and system-wide aspects. It also presents various technical solutions.\n"
},
{
	"uri": "http://example.org/09_decisions/",
	"title": "Design Decisions",
	"tags": [],
	"description": "This section enables you to understand two fundamental design decisions of DokChess in detail.",
	"content": "Section 9 Design Decisions This section enables you to understand two fundamental design decisions of DokChess in detail.\n"
},
{
	"uri": "http://example.org/04_solutionstrategy/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "4.1 Introduction to the Strategy The following table contrasts the quality goals of DokChess (→ Section 1.2) with matching architecture approaches and thus provides easy access to the solution.\nQuality Goal Matching approaches in the solution Accessible example (Analysability) architectural overview structured by arc42explicit, object-oriented domain modeldetailed documentation of public interfaces with Javadoc Platform appealing to experiments (Changeability) widely spread programming language Java → (a)Interfaces for core abstractions (for instance: position evaluation, game rules)immutable objects (position, move, \u0026hellip; ) make implementation of many algorithms easier\u0026ldquo;plugging\u0026rdquo; of elements with dependency injection leads to interchangeability → (b)High test coverage as a safety net Using existing frontends (Interoperability) Use of the common communication protocol XBoard, → (c)Use of portable Java → (a) Acceptable playing strength (Attractiveness) Integration of chess opening book libraries → (d)implementation of minimax algorithm and a proper position evaluation → (e)Integration tests with chess problems for tactics and mate positions Quick response to opponent\u0026rsquo;s moves (Efficiency) Reactive extensions for concurrent calculation with newly found better moves as events → (f) Optimization of minimax by alpha-beta pruning → (e) Efficient domain model implementationIntegration tests with time limits Small letters in brackets, e.g. → (x), link individual approaches from the right hand of the table to the following architectural overview diagram. The remaining section 4 introduces significant architectural aspects and refers to further information.\nFig.: DokChess Architectural Overview Diagram\n"
},
{
	"uri": "http://example.org/12_glossary/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " \u0026ldquo;The game of chess is played between two opponents who move their pieces on a square board called a ‘chessboard’.\u0026rdquo;\nFrom the FIDE Laws of Chess\nThe following glossary contains English chess terms and terms from the world of computer chess. Some of them go beyond the vocabulary of infrequent or casual chess players.\nSee FIDE Laws of Chess or the Wikipedia glossary of chess for more information.\nNames of the Chess Pieces Chessboard Geometry \u0026ldquo;The chessboard is composed of an 8 x 8 grid of 64 equal squares alternately light (the ‘white’ squares) and dark (the ‘black’ squares).\u0026rdquo;\nFrom the FIDE Laws of Chess\n"
},
{
	"uri": "http://example.org/10_qualityrequirements/",
	"title": "Quality Requirements",
	"tags": [],
	"description": "The quality scenarios in this section depict the fundamental as well as other required quality properties. They allow the evaluation of decision alternatives.",
	"content": "Section 10 Quality Requirements The quality scenarios in this section depict the fundamental quality goals as well as other required quality properties. They allow the evaluation of decision alternatives.\n"
},
{
	"uri": "http://example.org/05_buildingblockview/01_level1/",
	"title": "Level 1",
	"tags": [],
	"description": "",
	"content": "5.1\tBuilding Block View, Level 1 DokChess breaks down in four subsystems as presented below. The dashed arrows represent logical dependencies between the subsystems (\u0026ldquo;x -\u0026gt; y\u0026rdquo; for \u0026ldquo;x depends on y\u0026rdquo;). The squared boxes on the membrane of the system are interaction points (\u0026ldquo;ports\u0026rdquo;) with the outside world (→ 3.2 Deployment Context).\nFig.: DokChess, building block view, level 1\nSubsystem Short description Text UI Realizes communication with a client using the XBoard protocol. Rules Provides the rules of chess and for instance can determine all valid moves for a position. Engine Contains the determination of a next move starting from a game situation. Opening Provides standard moves of the chess opening literature for a game situation. Table: Subsystems overview of DokChess Section → 6.1 \u0026ldquo;Move Determination Walkthrough\u0026rdquo; contains an example of the interaction between the subsystems at runtime.\n"
},
{
	"uri": "http://example.org/06_runtimeview/01_move_determination/",
	"title": "Move Determination",
	"tags": [],
	"description": "",
	"content": "6.1 Move Determination Walkthrough After establishing the XBoard protocol, the client (white) starts a game by indicating a move. The following sequence diagram shows an example interaction at the subsystem level from the input \u0026ldquo;e2e4\u0026rdquo; (white pawn e2-e4) to DokChess\u0026rsquo; response, which is the output \u0026ldquo;move b8c6\u0026rdquo; (black knight b8-c6, \u0026ldquo;Nimzowitsch defense\u0026rdquo;).\nFig.: Sample interaction for move determination\nFirst, the Text UI subsystem validates the input with the aid of the Rules subsystem (→ Concept 8.4 \u0026ldquo;Plausibility Checks and Validation\u0026rdquo;). The move in the example is recognized as legal and performed on the (stateful) Engine (the performMove message) afterward. Then, the Text UI subsystem asks the engine to determine its move. Since move computation can take a long time, but DokChess should still continue to react to inputs, this call is asynchronous. The engine comes back with possible moves.\nThe Engine examines at first whether the opening book has something to offer. In the example, this is not the case. The engine has to calculate the move on its own. It then accesses the Rules and determines all valid moves as candidates. Afterward, it investigates and rates them, and gradually reports better moves (better from the perspective of the engine) back to the caller (the Text UI subsystem). Here, the observer pattern is used (implementation with reactive extensions).\nThe example diagram shows that two moves have been found (pawn e7-e5, knight b8-c6) and finally the message, that the search is complete, so the engine does not provide better moves. The Text UI subsystem takes the last move of the Engine and prints it as a string to standard output according to the XBoard protocol: \u0026ldquo;move b8c6\u0026rdquo;.\n"
},
{
	"uri": "http://example.org/11_risks/",
	"title": "Risks",
	"tags": [],
	"description": "The following risks have been identified at the beginning of the project.",
	"content": "Section 11 Risks The following risks have been identified at the beginning of the project. They influenced the planning of the first three iterations significantly. Since the completion of the third iteration the risks are mastered. This architectural overview shows the risks, including the former eventuality planning, because of their large impact on the solution.\n"
},
{
	"uri": "http://example.org/04_solutionstrategy/02_structure/",
	"title": "Structure",
	"tags": [],
	"description": "",
	"content": "4.2 Structure of DokChess DokChess is implemented as a Java program with a main routine. It is roughly split into the following parts:\nAn implementation of the rules of chess The engine itself, which selects the moves The connection to a graphical user interface via the XBoard protocol An adapter for a specific opening book format (Polyglot Opening Book) This decomposition allows you to replace things such as the communication protocol or the opening book format if necessary. All parts are abstracted through interfaces. Their implementations are assembled via dependency injection (→ 5. Building Block View, → 8.1 Dependencies Between Modules). The decomposition further allows the software, especially the chess algorithms, to be tested automatically. (→ 8.7 Testability).\nThe interaction between algorithms takes place using the exchange of data structures motivated by the domain implemented as Java classes (piece, move and so on, → 8.2 Chess Domain Model). Here, better understandability is preferred at the cost of efficiency. Nevertheless, DokChess reached an acceptable playing strength, as a run through the corresponding scenarios shows (→ 10. Quality Scenarios).\nThe key element of the data structure design is the game situation. This includes the placement of the chess pieces and other aspects that belong to the position (such as which side moves next). Again readability is preferred to efficiency in the implementation of the class motivated by the domain. An important aspect is that, like all other domain classes this class is immutable (→ Decision 9.2 \u0026ldquo;Are position objects changeable or not?\u0026rdquo;).\n"
},
{
	"uri": "http://example.org/07_deploymentview/01_windows_infrastructure/",
	"title": "Windows Infrastructure",
	"tags": [],
	"description": "",
	"content": "7.1 Windows Infrastructure The following deployment diagram shows the use of DokChess on Windows without an opening book. Arena is used as an example frontend (→ Decison 9.1 \u0026ldquo;How does the engine communicate with the outside world?\u0026rdquo;).\nFig.: Deploying DokChess on a Windows PC\nSoftware Requirements on a PC:\nJava Runtime Environment SE 11 (or higher) The JVM (javaw.exe) is in the PATH, otherwise adapt dokchess.bat Arena DokChess.jar contains the compiled Java source code of all the modules and all the necessary dependencies (\u0026ldquo;Uber-jar\u0026rdquo;). The script file dokchess.bat starts the Java Virtual Machine with DokChess. Both are available on the computer in a common directory, because dokchess.bat relatively addresses the jar file.\nWithin Arena, the script file is declared in the following menu \u0026ldquo;Engine | Install a new Engine \u0026hellip;\u0026rdquo;. You will see a file selection, the file type can be limited to * .bat files. Then, set the engine type to \u0026ldquo;Winboard\u0026rdquo;. In other chess frontends, declaring an engine is very similar See corresponding documentation for details.\nOpen Issues Some frontends under Windows only allow the integration of a *.exe file as an engine. In this case DokChess would have to be wrapped appropriately.\n"
},
{
	"uri": "http://example.org/04_solutionstrategy/03_gamestrategy/",
	"title": "Game Strategy",
	"tags": [],
	"description": "",
	"content": "4.3 Game Strategy For the integration of opening libraries, the \u0026ldquo;Polyglot Opening Book\u0026rdquo; file format was implemented (→ Building Block View 5.5 \u0026ldquo;Subsystem Opening (Blackbox)\u0026rdquo;). This way, DokChess responds with profound chess knowledge in the beginning of a game.\nThe classic minimax algorithm with a fixed search depth in the game tree is responsible for the strategy as the game continues. Its basic implementation is single-threaded. The evaluation of a position at an end node in the game tree is based solely on the material (→ 5.6 Building Block View, Level 2 \u0026ldquo;Engine (Whitebox)\u0026rdquo;). Nevertheless, these simple implementations already meet the quality scenarios under the given constraints.\nAn alpha-beta pruning illustrates the simple replacement of algorithms. Playing strength and efficiency considerably improve by searching the tree more deeply within the same computation time. The immutable data structures of DokChess also facilitate implementing concurrent algorithms; a parallel minimax algorithm is included as an example.\n"
},
{
	"uri": "http://example.org/12_glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "The following glossary contains English chess terms and terms from the world of computer chess.",
	"content": "Section 12 Glossary The following glossary contains English chess terms and terms from the world of computer chess.\n"
},
{
	"uri": "http://example.org/05_buildingblockview/02_textui/",
	"title": "Text UI",
	"tags": [],
	"description": "",
	"content": "5.2 Subsystem Text UI (Blackbox) Intent/Responsibility This subsystem implements the communication with a client (for example, a graphical user interface) using the text-based XBoard protocol (→ Decision V.9.1). It reads commands from standard input, checks them against the rules of the game and converts them for the Engine. Responses from the Engine (especially the moves) will be accepted by the subsystem as events, formatted according to the protocol and returned via standard output. Thus the subsystem is driving the whole game.\nInterfaces The subsystem provides its functionality via the Java class org.dokchess.textui.xboard.XBoard.\nFig.: Classes XBoard und Main\nMethod Short description setInput Set the protocol input with a dependency injection (→ Concept V.8.1). Typically, the standard input (stdin), automated tests use a different source. setOutput Set the protocol output. Typically, the standard output (stdout), automated tests may use a different target. setChessRules Sets an implementation of the game rules, → Subsystem Rules (Black Box) setEngine Sets an implementation of the engine, → Subsystem Engine (Black Box) play Starts the actual communication (input / processing / output) in a infinite loop until the quit command. Table: Methods of class XBoard Files The implementation is located below the packages\norg.dokchess.textui\u0026hellip;\nOpen Issues The implementation of the XBoard protocol is incomplete. Nevertheless it is sufficient for the requirements of DokChess. But in particular, the following features are not supported:\nTime control Permanent brain (thinking while the opponent thinks) Draw-offers and giving up of the opponent Chess variants (alternative rules, such as Chess960) "
},
{
	"uri": "http://example.org/04_solutionstrategy/03_connection/",
	"title": "Connection",
	"tags": [],
	"description": "",
	"content": "4.4 The Connection of the Engine DokChess has no graphical user interface. Instead communication takes place via standard input and output. The text-based XBoard acts as a communication protocol (→ Decision 9.1 \u0026ldquo;How does the engine communicate with the outside world?\u0026rdquo;). You can use DokChess interactively with the command line if you know the XBoard commands and are able to interpret the engine responses (→ Concept 8.3 User Interface). See image below:\nThe actual DokChess engine is attached by a reactive approach (\u0026ldquo;Reactive Extensions\u0026rdquo;) (→ 6.1 Runtime view \u0026ldquo;Move Determination Walkthrough\u0026rdquo;). DokChess is accessible even during its analysis. This way, for instance a user can force the engine to move immediately.\nOn Windows, integrating DokChess in a UI is done with a batch file (*.bat). It starts the Java Virtual Machine (JVM) with the class with the main method as a parameter (→ 7. 7. Deployment View).\n"
},
{
	"uri": "http://example.org/05_buildingblockview/03_rules/",
	"title": "Rules",
	"tags": [],
	"description": "",
	"content": "5.3\tSubsystem Rules (Blackbox) Intent/Responsibility This subsystem accounts for the rules of chess according to the International Chess Federation (FIDE). It determines all valid moves for a position and decides whether it is a check, a checkmate or a stalemate.\nInterfaces The subsystem provides its functionality via the Java interface\norg.dokchess.rules.ChessRules.\nDefault implementation of the interface is class\norg.dokchess.rules.DefaultChessRules.\nFig.: Interface ChessRules\nMethod Short description getStartingPosition Returns the starting position of the game. White begins. getLegalMoves Returns the set of all legal moves for a given position. The current player is determined from the position parameter. In case of a mate or stalemate an empty collection is the result. Thus the method never returns null. isCheck Checks whether the king of the given colour is attacked by the opponent. isCheckmate Checks whether the given position is a mate. I.e. the king of the current player is under attack, and no legal move changes this. The player to move has lost the game. isStalemate Checks whether the given position is a stalemate. I.e. the current player has no valid move, but the king is not under attack. The game is considered a draw. Table: Methods of interface ChessRules → Concept 8.2 Chess Domain Model describes the types used in the interface as call and return parameters (Move, Position, Colour). Refer to the source code documentation (javadoc) for more details.\nFiles The implementation is located below the packages\norg.dokchess.rules\u0026hellip;\nOpen Issues Apart from the stalemate, the subsystem can not recognize any draw. In particular, the following rules are not implemented (→ Risk 11.2 \u0026ldquo;Risk: Effort of implementation\u0026rdquo;):\n50 moves rule Threefold repetition "
},
{
	"uri": "http://example.org/05_buildingblockview/04_engine/",
	"title": "Engine",
	"tags": [],
	"description": "",
	"content": "5.4 Engine (Blackbox) Intent/Responsibility This subsystem contains the determination of a next move starting from a game position. The position is given from outside. The engine itself is stateful and always plays one game at the same time. The default implementation needs an implementation of the game rules to work. An opening library, however, is optional.\nInterfaces The Engine subsystem provides its functionality via the Java interface\norg.dokchess.engine.Engine.\nDefault implementation is the class\norg.dokchess.engine.DefaultEngine.\nFig.: Interface Engine and class DefaultEngine\nMethod Short description setupPieces Sets the state of the engine to the specified position. If currently a move calculation is running, this will be cancelled. determineYourMove Starts the determination of a move for the current game situation. Returns move candidates asynchronously via an Observable (→ 6.1 Runtime View \u0026ldquo;Move Determination Walkthrough\u0026rdquo;). The engine does not perform the moves. performMove Performs the move given, which changes the state of the engine. If currently a move calculation is running, this will be canceled. close Closes the engine. The method makes it possible to free resources. No move calculations are allowed afterwards. Table: Methods of the Engine interface Method Short description DefaultEngine Constructors, set an implementation of the chess rules, → Subsystem Rules (Black Box) and an (optional) opening book, whose moves will be preferred to own considerations, → Subsystem Opening (Black Box). Table: Methods of the DefaultEngine class (in addition to the Engine interface) → Concept 8.2 Chess Domain Model (\u0026ldquo;Chess domain model\u0026rdquo;) describes the types used in the interface as call and return parameters (Move, Position). Refer to the source code documentation (javadoc) for more information.\nYou find details of the Engine subsystem implementation in the white box view in section 5.6 of this overview.\nFiles The implementation of the Engine subsystem and corresponding unit tests are located below the packages\norg.dokchess.engine\u0026hellip;\n"
},
{
	"uri": "http://example.org/05_buildingblockview/05_opening/",
	"title": "Opening",
	"tags": [],
	"description": "",
	"content": "5.5 Subsystem Opening (Blackbox) Intent/Responsibility This subsystem provides opening libraries and implements the Polyglot opening book format. This format is currently the only one available, which is not proprietary. Corresponding book files and associated tools are freely available on the Internet.\nInterfaces The Opening subsystem provides its functionality via the Java interface\norg.dokchess.opening.OpeningLibrary.\nThe class org.dokchess.opening.polyglot.PolyglotOpeningBook provides one possible implementation.\nFig.: Schnittstelle Eroeffnungsbibliothek, Implementierung PolyglotOpeningBook\nMethod Short description lookUpMove Returns a standard move for the specified position from the library, or null. Table: Methods of the interface OpeningLibrary PolyglotOpeningBook The PolyglotOpeningBook class is an adapter for the Polyglot opening book file format. Implementation of OpeningLibrary that reads a binary file in the appropriate format and returns a move to the specified position, if the library contains any.\nMethod Short description PolyglotOpeningBook Constructor, expects the input file. setSelectionMode Sets the mode to select a move, if there is more than one candidate in the library for the given position. Table: Methods of the class PolyglotOpeningBook (in addition to interface OpeningLibrary): → Concept 8.2 Chess Domain Model describes the types used in the interface as call and return parameters (Move, Position).\nFiles The implementation, unit tests and test data for the Polyglot file format are located below the packages\norg.dokchess.opening\u0026hellip;\nOpen Issues The implemented options for a move selection from the Polyglot opening book in case of several candidates are limited (the first, the most often played, by chance). The implementation can not handle multiple library files at the same time. It can therefore not mix them to combine the knowledge. "
},
{
	"uri": "http://example.org/01_introduction/01_requirements/",
	"title": "Requirements Overview",
	"tags": [],
	"description": "",
	"content": "1.1 Requirements Overview What is \u0026ldquo;applicationname\u0026rdquo; ? xxx. yyy zzz Uygulama mimarisi hakkında temel bilgiler\nEssential Features aaa bbb ccc Uygulamanın öne çıkan özellikleri\n"
},
{
	"uri": "http://example.org/12_glossary/02_terms/",
	"title": "Terms",
	"tags": [],
	"description": "Table with English chess terms",
	"content": " Term Definition 50 move rule A rule in chess, which states that a player can claim a draw after 50 moves whilst in the meantime no pawn has been moved and no piece has been taken. Alpha-beta pruning Significant improvement of the Minimax algorithm, in which parts of the search tree can be \u0026ldquo;cut off\u0026rdquo; without coming to a different resulting move. Castling A special move in chess where both the players\u0026rsquo;s king and one the rooks are moved. For castling, different conditions must be met. Chess 960 A chess variant developed by Bobby Fischer. The initial position is drawn from 960 possibilities. Also known as Fischer Random Chess. to drop (a piece) A beginner\u0026rsquo;s mistake in chess. A piece is dropped, if it is moved to a field attacked by the opponent and can be taken by him or her without risk or disadvantage. Draw A chess game which ends with no winner. There are various ways to end it with a draw, one of them is stalemate. Half-move Single action (move) of an individual player, unlike the sequence of a white and a black move which is counted as a move e.g. when numbering. En passant A special pawn move in chess. If a pawn moves on two squares and an opposing pawn could capture him, if he would advance only one square, the latter pawn may capture it en passant. Endgame The final stage of a chess game. It is characterised when only a few types of pieces are left on the board. Engine Part of a chess program which calculates the moves. Typically, an engine has no graphical user interface. Also known as \u0026lsquo;chess engine\u0026rsquo;. FEN Forsyth-Edwards Notation. Compact representation of a chess board position as a character string. Supported by many chess tools. Used in DokChess by unit and integration tests. Explanation see e.g. [Wikipedia] (https://en.wikipedia.org/wiki/Forsyth–Edwards_Notation) FIDE Fédération Internationale des Échecs, international chess organisation Fork A tactic in chess in which a piece attacks two (or more) of the opponent\u0026rsquo;s pieces simultaneously. Knight fork Particularly common form of a fork with a knight as attacking piece. Mate End of a chess game in which the king of the player to move is attacked and the player has no valid move left (i.e. can not escape the attack). The player has lost. Also known as \u0026lsquo;checkmate\u0026rsquo;. Minimax algorithm Algorithm to determine the best move under the consideration of all options of both players. Opening First stage of a chess game. Knowledge and best practices of the first moves in chess fill many books and large databases. Polyglot Opening Book Binary file format for opening libraries. Unlike many other formats for this purpose the documentation of it is freely accessible. Promotion A rule in chess which states that a pawn who reached the opponent\u0026rsquo;s base line is immediately converted into a queen, rook, bishop or knight. Skewer A tactic in chess in which a straight line passing piece stands on a rank, file or diagonal with two opponents pieces and forces the fore of the two pieces to move away. Stalemate End of a chess game in which the player to move does not have a valid move, but his or her king is not under attack. The game is considered a draw. Threefold repetition A rule in chess, which states that a player can claim a draw if the same position occurs at least three times. WinBoard protocol See XBoard protocol. XBoard protocol Text-based protocol for communication between chess frontends and engines. Also referred to as \u0026ldquo;WinBoard\u0026rdquo; or (more rarely) as \u0026ldquo;Chess Engine Communication Protocol\u0026rdquo;. "
},
{
	"uri": "http://example.org/05_buildingblockview/06_level_2_engine/",
	"title": "Level 2: Engine",
	"tags": [],
	"description": "",
	"content": "5.6 Level 2: Engine (Whitebox) The engine breaks down in modules Search and (position) Evaluation as shown in the following diagram. If available, the determination of the move is initially delegated to an opening book. Only if the book does not provide a standard move Search is used.\nFig.: Engine, building block view, level 2\nModule Short description Search Determines the optimal move for a position under certain conditions. Evaluation Evaluates a position from an opponent\u0026rsquo;s perspective. Table: Modules of Engine subsystem "
},
{
	"uri": "http://example.org/01_introduction/02_qualitygoals/",
	"title": "Quality Goals",
	"tags": [],
	"description": "",
	"content": "1.2 Quality Goals The following table describes the key quality objectives of XXX. The order of the goals gives you a rough idea of their importance.\nQuality Goal Motivation/description a b a b a b a b The quality scenarios in section 10 detail these goals and serve to evaluate their achievement.\n"
},
{
	"uri": "http://example.org/05_buildingblockview/07_search/",
	"title": "Search",
	"tags": [],
	"description": "",
	"content": "5.7 Search (Blackbox) Intent/Responsibility The module determines the optimal move for a position under certain conditions. In the game of chess an optimal move always exists, theoretically. The high number of possible moves and the resulting incredible mass of game situations to consider makes it impossible to determine it in practice. Common algorithms like the Minimax therefore explore the \u0026ldquo;game tree\u0026rdquo; only up to a certain depth.\nInterfaces The module provides its functionality via the Java interface\norg.dokchess.engine.search.Search.\nClass org.dokchess.engine.search.MinimaxAlgorithm implements the interface with the Minimax algorithm. The class MinimaxParallelSearch uses the algorithm and implements the same interface Search. It examines several subtrees concurrently; if it finds a better move the caller receives a message onNext via the observer pattern. The search indicates the completion of its work with the message onComplete.\nFig.: Interface Search, classes MinimaxAlgorithm and MinimaxParallelSearch\nMethod Short description searchMove Starts a search for a move on the specified position. Returns gradually better moves as events on the passed observer. The end of the search (no better move found) is also signaled to the observer. cancelSearch Cancels the current search. close Closes the search completely. No moves may be determined after calling this method. Table: Methoden der Schnittstelle Suche Method Short description setEvaluation Set the evaluation function on which the positions are rated when the maximum search depth is reached. → Module Evaluation (Black Box) setChessRules Sets an implementation of the chess rules via dependency injection, → Subsystem Rules (Black Box) setDepth Set the maximum search depth in half moves. That means at 4 each player moves twice. determineBestMove Determines the optimal move according to minimax for the position passed and given evaluation at fixed search depth. The method blocks and is deterministic. Table: Methods of the class MinimaxAlgorithm Files The implementation is located below the packages\norg.dokchess.engine.search\u0026hellip;\n"
},
{
	"uri": "http://example.org/01_introduction/03_stakeholders/",
	"title": "Stakeholders",
	"tags": [],
	"description": "Illustrates the stakeholders of DokChess and their respective intentions.",
	"content": "1.3 Stakeholders The following table illustrates the stakeholders of XXXX and their respective intentions.\nUygulama paydaşları ve durumları aşağıdaki tabloya yazılacak.\nWho? Matters and concern Software Architects item1item2 Developers item1item2 DevOps Engineer item1item2 "
},
{
	"uri": "http://example.org/05_buildingblockview/08_evaluation/",
	"title": "Evaluation",
	"tags": [],
	"description": "",
	"content": "5.8 Evaluation (Blackbox) Intent/Responsibility The module evaluates a position from an opponent\u0026rsquo;s perspective. Result is a number where 0 is a balanced situation. A positive number describes an advantage for the player, a negative one a drawback. The higher the number, the greater the advantage or disadvantage. The module makes it therefore possible to compare positions with each other.\nInterfaces The Evaluation module provides its functionality via the Java interface\norg.dokchess.engine.eval.Evaluation.\nThe class org.dokchess.engine.eval.StandardMaterialEvaluation is a very simple implementation. The interface contains constants for typical ratings.\nFig.: Interface Evaluation and class StandardMaterialEvaluation\nMethod Short description evaluatePosition Returns an evaluation value for the given position from the view of the specified player\u0026rsquo;s colour. The higher the better. Table: Methods of the interface Evaluation StandardMaterialEvaluation The implementation class StandardMaterialEvaluation takes only the present pieces (material) into account. Each piece type has a value (pawn 1, knight 3, \u0026hellip;, queen 9). The pieces on the board are added accordingly. Own figures are positive, opponent\u0026rsquo;s pieces negative. Accordingly, with balanced material the result is 0. If you lose a queen, the value drops by 9.\nFiles The implementation is located below the packages\norg.dokchess.engine.eval\u0026hellip;\nOpen Issues In the pure material evaluation it does not matter where the pieces stand. A pawn in starting position is worth as much as one short before promotion. And a knight on the edge corresponds to a knight in the center. There is plenty of room for improvement, which has not been exploited because DokChess should invite others to experiment.\n"
},
{
	"uri": "http://example.org/",
	"title": "adesso Turkey",
	"tags": [],
	"description": "",
	"content": "adesso Turkey arc24 document template fully designed for documentation.\nThis theme is a partial porting of the Learn theme of Grav, a modern flat-file CMS written in PHP.\nLearn theme works with a page tree structure to organize content : All contents are pages, which belong to other pages. [read more about this]\ndeneme\nMain features Unlimited menu levels Automatic next/prev buttons to navigate through menu entries "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]